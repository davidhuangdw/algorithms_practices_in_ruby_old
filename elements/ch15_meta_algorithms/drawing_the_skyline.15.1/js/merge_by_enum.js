// Generated by CoffeeScript 1.7.1
(function() {
  var Enum, adjoint, cmp, divide, draw_by_merge, merge, method, puts, segment, zip;

  Enum = require('./enum');

  puts = console.log;

  method = function(name) {
    return function(obj) {
      return obj[name]();
    };
  };

  zip = function(a, b) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push([a[i], b[i]]);
    }
    return _results;
  };

  cmp = function(a, b) {
    var x, y, _i, _len, _ref, _ref1;
    _ref = zip(a, b);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
      if (x !== y) {
        return x - y;
      }
    }
    return 0;
  };

  segment = function(left, right, height) {
    return {
      left: left,
      right: right,
      height: height,
      to_ary: function() {
        return [this.left, this.right, this.height];
      },
      cmp: function(other) {
        return cmp(this.to_ary(), other.to_ary());
      }
    };
  };

  divide = function(arr) {
    var hf;
    hf = Math.ceil(arr.length / 2);
    return [arr.slice(0, hf), arr.slice(hf)];
  };

  adjoint = function(segments) {
    var last, result, x, _i, _len, _ref;
    result = [];
    _ref = segments.slice(0);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      last = result[result.length - 1];
      if ((last != null) && last.height === x.height && last.right === x.left) {
        last.right = x.right;
      } else {
        result.push(x);
      }
    }
    return result;
  };

  merge = (function() {
    var extract_overlap, extract_smaller, extract_unoverlap, is_overlap_begin, is_separate, l, peek, r, x, y;
    l = r = void 0;
    x = y = void 0;
    peek = function() {
      var _ref;
      return _ref = [l.peek(), r.peek()], x = _ref[0], y = _ref[1], _ref;
    };
    is_separate = function() {
      return x.right <= y.left;
    };
    is_overlap_begin = function() {
      return x.left === y.left;
    };
    extract_overlap = function() {
      x.height = Math.max(x.height, y.height);
      if (x.right === y.right) {
        r.next();
      } else {
        y.left = x.right;
      }
      return l.next();
    };
    extract_unoverlap = function() {
      var result;
      result = segment(x.left, y.left, x.height);
      x.left = y.left;
      return result;
    };
    extract_smaller = function() {
      var _ref;
      peek();
      if (x.cmp(y) > 0) {
        _ref = [r, l], l = _ref[0], r = _ref[1];
        peek();
      }
      if (is_separate()) {
        return l.next();
      }
      if (is_overlap_begin()) {
        return extract_overlap();
      } else {
        return extract_unoverlap();
      }
    };
    return function(left, right) {
      var result, _ref;
      _ref = [Enum.Enum(left), Enum.Enum(right)], l = _ref[0], r = _ref[1];
      result = [];
      Enum.loop(function() {
        return result.push(extract_smaller());
      });
      Enum.loop(function() {
        return result.push(l.next());
      });
      Enum.loop(function() {
        return result.push(r.next());
      });
      return result;
    };
  })();

  draw_by_merge = (function() {
    var safe_draw;
    safe_draw = function(buildings) {
      var l, r, _ref;
      if (buildings.length <= 1) {
        return buildings;
      }
      _ref = divide(buildings), l = _ref[0], r = _ref[1];
      return merge(safe_draw(l), safe_draw(r));
    };
    return function(buildings) {
      buildings = buildings.map(function(a) {
        return segment.apply(null, a);
      }).sort(function(a, b) {
        return a.cmp(b);
      });
      return (adjoint(safe_draw(buildings))).map(function(s) {
        return s.to_ary();
      });
    };
  })();

  module.exports = {
    segment: segment,
    draw_by_merge: draw_by_merge
  };

}).call(this);

//# sourceMappingURL=merge_by_enum.map
